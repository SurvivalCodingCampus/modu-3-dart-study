# 테스트 이론

## 테스트를 통한 품질 향상

테스트를 하는 방법들

수동 테스트 : 인간이 하는 테스트

단위 테스트 : 1개의 함수를 테스트

통합 테스트 : 여러개 연관된 클래스나 함수를 함께 테스트

## 테스트 방법론

### 화이트 박스 테스트

- 내부 구조와 동작에 중점을 두고 테스트하는 방법
- 코드의 내부 로직, 제어 흐름, 데이터 흐름 등을 이해하고 검증하는 데에 사용
- 테스트 케이스를 설계할 때 코드의 특정 부분을 직접 확인
- 주요 기법으로는 구문 검사, 경로 검사, 조건/분기 검사 등이 있다

### 블랙박스 테스트

- 소프트웨어의 내부 구조를 무시하고 기능을 테스트하는 방법
- 시스템이 어떻게 동작하는지에 대한 내부 정보를 알 필요 없이 사용자 관점에서 테스트
- 테스트 케이스는 입력 값과 예상 출력 값에 기반하여 설계
- 요구 사항을 충족하는지 확인하고, 시스템의 기능적 및 비기능적 요구 사항을 테스트
- 주요 기법으로는 등가 분할, 경계 값 분석, 상태 전이 테스트 등이 있다

## 단위(Unit) 테스트

단위 테스트란?

특정 모듈이 의도한 대로 잘 작동하는가를 테스트하는 가장 작은 단위의 테스트

모듈 = 메서드, 기능

## 테스트의 장점

- 장애에 관한 **신속한 피드백**
- 개발 주기에서 **조기 장애 감지**
- 회귀에 신경 쓸 필요 없이 코드를 최적화할 수 있도록 하는 **더 안전한 코드 리팩터링**
- 기술적 문제를 최소화하는 **안정적인 개발 속도**

### 테스트 케이스

가능한 모든 가능성의 범위를 테스트하는 것이 좋은 테스트 케이스이다

- 동등 분할
- 경계값 분석
- 등의 기법이 있음

### 단위 테스트가 꼭 필요한 경우

- DB
    - 스키마가 변경되는 경우
    - 모델 클래스가 변경되는 경우
- Network
    - 예측한 데이터가 제대로 들어오는지
- 데이터 검증
    - 예측한 데이터를 제대로 처리하고 있는지

![image.png](attachment:3565e8dd-ca1a-47f1-877b-96508f47e883:image.png)

## Mock 객체 활용

때때로 단위 테스트는 **라이브 웹 서비스 또는 데이터베이스**에서 데이터를 가져오는 클래스에 의존할 수 있다

이는 다음과 같은 몇 가지 이유로 불편하다

- 테스트 실행 속도가 느려진다
- 예기치 않은 결과를 반환하면 통과 테스트가 실패하기 시작할 수 있다.
- 가능한 모든 성공 및 실패 시나리오를 테스트하는 것은 어렵습니다.
- 따라서 라이브 웹 서비스나 데이터베이스에 의존하는 대신 이러한 종속성을 Mocking할 수 있다.

Mock은 라이브 웹 서비스 또는 데이터베이스를 에뮬레이션하고 상황에 따라 특정 결과를 반환할 수 있다.

## 좋은 Unit Test 의 6가지 조건

Fast (빠르고)

Reliable (믿을 수 있고)

Independent (독립적인)

Ease of Maintenance (유지 관리가 쉽고)

Nearly compacted code (거의 압축적인 코드)

Dependencies should be less (의존성이 적어야 한다)

# Model Class, Repository

## Model Class의 책임과 열할

- 모델 객체 클래스의 속성에 대한 데이터를 조회할 수 있는 클래스
- 일반적으로 별도의 기능을 가지지 않는 순수한 클래스로 작성
- 데이터 소스를 앱에서 필요한 형태로 변환한 데이터, 앱 개발을 편리하게 해 주는 역할
- View에 보여질 데이터를 담는 객체
    - View == 눈에 보이는 부분
- 비슷한 용어들
    - 도메인 모델
    - Entity
    - DTO
    - POJO
    - VO
    - 데이터 클래스 (4종 세트 포함)

      hashCode, toString(), copyWith(), == (equals)

## 모델링 방법

- DDD (Domain Driven Design)
- ORM (Object-relational mapping)

### DDD (Domain Driven Design)

- Domain 의 정의
    - 유사한 업무의 집합
    - 특정 상황(주문, 결재, 로그인)이나 특정 객체(유저, 손님)가 중심이 될 수 있음
- 모델 클래스
    - 도메인을 클래스로 작성한 것

### ORM (Object-relational mapping)

- **ORM 의 정의**
    - 데이터 소스가 DB 인 경우 DB 와 모델간 상호 변환을 도와주는 기법
    - ORM은 DB 를 활용할 경우에 따로 살펴봐도 됨

## 구현기능

- 불변 객체
- 값 변경을 위해 copyWith() 제공
- ==, hashCode 재정의
- toString() 재정의
- (옵션) 직렬화, 역직렬화 제공

# Repository

## Repository 패턴

Repository 패턴은 소프트웨어 개발에서 데이터 저장소에 접근하는 객체를 추상화하고,

데이터소스(DB, File 등)와의 통신을 담당하는 객체를 캡슐화하는 디자인 패턴이다

## Repository 의 책임과 역할

- **데이터 접근에 대한 추상화 계층**
- 데이터 소스 은닉
- 도메인 객체와 데이터 소스 사이의 중재자
- 데이터 매핑, 변환 담당

## Repository 패턴의 이점

- 데이터 접근 추상화
    - 데이터 소스 구현 세부사항 은닉
    - 일관된 인터페이스 제공
- 유지보수성 향상
    - 관심사 분리
    - 코드 재사용성
- 테스트 용이성
    - 데이터 소스 Mocking 가능
    - 단위 테스트 작성 용이
- 확장성
    - 새로운 데이터 소스 추가 용이
    - 기존 코드 수정 최소화
    - 인터페이스 기반 설계

### 데이터 소스는 데이터 처리에 집중

JSON String 을 Map<String, dynamic> 이나 List<Map> 으로 변경하는데 집중

CRUD 에 집중

용도에 맞게 구현

- File 을 조작하거나
- 서버와 통신하거나
- 메모리를 사용하거나

Repository는 비지니스 로직에 집중

- Map 을 모델 클래스로 변환에 집중
- 그리고 앱에 필요한 기능을 제공하는데 집중

### 도메인 특화 기능 제공의 장점

- 도메인 의도가 명확히 드러남
- 재사용 가능한 쿼리 로직
- 데이터 소스 구현과 분리된 비즈니스 요구사항 처리

## 주의할 점

- Repository는 비즈니스 로직에 집중
- 복잡한 비즈니스 로직은 더 상위 계층으로
- 성능을 고려한 쿼리 설계 필요

## 정리

- DataSource는 데이터 접근 방법에 집중
- Model 객체는 데이터 구조 정의 (순수 데이터만, 불변)
- Repository는 DataSource 사용 및 관리, 비즈니스 로직에 집중
- 단순하고 명확한 구조 유지