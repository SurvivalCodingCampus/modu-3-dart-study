# 9일차 다형성

## 다형성(polymorphism)

<br>

- 다형성 : 어떤 것을 이렇게도 부를 수 있고, 저렇게도 부를 수 있는 것
- 인터페이스 : 공통 기능을 묶는 용도로 씀
    - 일을 맡기는 입장에서도 좋음. implement로 강제할 수 있으니까
    - 반복되는 작업이 있을 때, 비슷한 얘들끼리 묶어버리면 코드 중복이 줄고 간결해짐.
    - 메서드 없는 인터페이스를 만들 수 있음. 그룹화 하는 용도.
    - 인터페이스를 Implements하는 인터페이스를 만들 수 있음.
- Dart는 메서드 오버로딩이 불가능하고 다형성으로 해결이 가능함.

<br>

- 내가 Thing 인터페이스를 선언하면 이것을 타입처럼 같은 인터페이스를 가진 것들을 모을 수 있음.

```dart
final List<Thing> things = [
  Book(),
  Computer()
]
```

<br>

- 인스턴스화 할 때 선언을 추상클래스, 인터페이스로 지정 가능함.
- 선언을 상위 개념으로, 인스턴스 생성은 하위 개념으로 가능함.
- 인터페이스 타입으로 선언한 객체는 인터페이스에 있는 기능만 사용 가능. 다른 메서드는 안보임. 

<br>

## 다형성 문제

<br>

```
abstract class Monster {
  void run() {
    print('1번');
  }
}

class Slime extends Monster {
  @override
  void run() {
    print('2번');
  }
}

void main() {
  Slime slime = Slime();
  Monster monster = Slime();
  slime.run();
  monster.run();
}
```

<br>

- 답은 2번, 2번이 출력됨.
- 2개의 인스턴스 타입은 Slime임. 컴파일러는 Slime과 Monster로 각각 보지만 실제 인스턴스는 Slime임
- 타입을 컴파일러가 어디까지 볼 건지 지정해주는 필터라고 생각하면 될 것 같음.
    - Monster의 재료인 run까지 볼 수 있음. 따라서 Monster를 재료로 사용한 것까지 보임.

<br>

## 캐스팅

- 타입을 변경하는 것
- 타입 캐스팅을 하면 프로그램이 개발자를 믿고 잘했겠지 하고 타입을 바꿈. 
    - 틀리면 런타임에 틀릴 수 있기 때문에 위험함.
- 체크를 통과하면 캐스팅이 되는 걸로 좀 안전하게 코드를 짤 수 있음.

<br>