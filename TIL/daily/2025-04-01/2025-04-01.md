# 2025-04-01

# Model Class

## 주요 개념(필요성)

- **데이터 구조화(Data Modeling)**
    - 현실 데이터를 객체로 표현
    - 앱 내에서 어떤 데이터 어떻게 구성되는지 명확히 정의 함.
- **타입 안정성(Type Safety)**
    - 각 속성에 대해 데이터 타입을 지정함으로써, 앱에서 데이터 사용 시 잘못된 타입으로 인한 오류를 미연에 방지할 수 있음.
    - Dart의 정적 타입 시스템 덕분에 컴파일 시점에 이런 오류를 잡아내기 쉬움
- **불변성과 객체 복제**
    - **불변성 (Immutability)**
        - 앱에서 한 번 만들어진 데이터를 변경 불가능하게 만들고 싶을 때 변수를 `final`로 선언하면 된다.
        - 이렇게 하면 객체를 수정할 수 없고, 값을 바꾸고 싶다면 새로 만들어야 한다.
    - **객체 복제 (copyWith)**
        - 불변성을 유지하면서 일부 필드만 바꾸고 싶다면 `copyWith()` 메서드를 직접 만들어서 사용하는 것이 좋다.
        - `copyWith()` 메서드를 사용하면 기존 데이터를 바탕으로 일부만 수정된 객체를 쉽게 생성이 가능하다
- **객체 비교(동등성)**
    - Dart에서는 객체는 기본적으로 **메모리 주소를 기준으로 비교함.**
    - 그래서 값이 같더라도 `a == b`가 false일 수 있음.
    - 이걸 해결 하기 위해서는 `==` 연산자와 `hashCode`를 직접 `@override`해서 재정의 해야 됨

# Repository 패턴

## 개념

- 데이터를 가져오거나 정하는 역할을 담당하는 객체(Repository)를 만들어서, 앱의 다른 부분은 이 객체를 통해서만 데이터를 다루게 하는 구조

## 구성 요소

- **모델(Model)**
    - 앱에서 다루는 데이터 구조
- **데이터 소스(Data Source)**
    - 실제 데이터를 가져오거나 저장하는곳
    - Repository에서 실제 로직을 실행하는 부분
- **리포지토리 (Repository)**
    - 앱이 직접 접근하는 유일한 데이터 계층
    - 데이터가 어디서 오든, 앱은 Repository만 호출해서 데이터를 가져오면 됨
- **앱 로직 계층(UseCase, ViewModle등)**
    - Repository를 실제로 사용하는 계층
    - 보통 화면에 데이터를 보여주기 위한 로직을 여기서 처리

## Repository의 책임과 역할

- **데이터 접근 로직을 캡슐화**
    - **데이터가 어디에 있든 상관없이**, 앱은 Repository를 통해 접근
    - Repository는 **데이터를 가져오고 저장하는 "방법"을 숨기고**, 필요한 데이터만 전달
- **UI 또는 앱 로직과 데이터 소스 간의 중간 다리 역할**
    - Repository는 **ViewModel, Bloc, Controller 등 앱 로직 계층과 데이터 계층(DataSource)을 연결하는 인터페이스**
    - 앱 로직은 Repository만 신경 쓰면 되고, 데이터가 바뀌어도 다른 계층은 영향을 안 받
- **하나의 일관된 인터페이스 제공**
    - 예를 들어 `UserRepository`는 항상 같은 형태의 메서드 (`getUser()`, `updateUser()`, `deleteUser()` 등)를 제공해서, 어떤 화면에서든 **같은 방식으로 데이터를 다룰 수 있도록 보장**
- **Mock 테스트 지원**
    - **Mock 테스트**는 실제 객체를 흉내 내는 가짜 객체(Mock)를 만들어 테스트할 때 사용하는 방식
    - 외부 의존성(예: 서버 API, 데이터베이스, Firebase 등)을 테스트할 수 없거나, 테스트 속도를 높이고 싶을 때 유용

## Repository의 장점

- **코드의 재사용성과 확장성 증가**
    - Repository 하나만 잘 만들어 두면, 다른 페이지나 기능에서도 같은 방식으로 데이터를 다룰 수 있음.
    - 중복 코드 제거와 앱이 커져도 새로운 기능을 붙이기가 쉽다는 이점이 있음
- **구현과 사용의 분리 (느슨한 결합)**
    - 앱 로직은 Repository만 알고, 실제로 데이터를 가져오는 법은 몰라도 됨.
    - 데이터 소스를 바꿔도 앱 구조를 바꾸지 않아도 됨.
    - 테스트, 교체, 리팩토링이 쉬움
- **테스트하기 쉬움**
    - `abstract class UserRepository`를 기반으로 FakeRepository, MockRepository 등을 만들어서 테스트 코드에서 진짜로 작동하게 만들어 볼 수 있음
    - 자동화 테스트 환경에 유리함
    - 유닛 테스트에서 외부 의존성을 제거 할  수 있음
- **여러 데이터 소스 관리가 쉬움**
    - 한 앱에서 다양한 데이터 소스를 사용할 경우, 그걸 Repository에서 중앙 조절이 가능함.
    - 데이터 처리 전략을 유연하게 만들 수 있음
- **앱 구조가 명확해짐**
    - 기능이 많아 질수록 파일이 복잡해지기 마련이지만, Repository 패턴을 사용하면 계층이 분리 되어서 **어떤 파일이 어떤 역할을 하는지 명확**해짐.
    - 팀 프로젝트에서 역할 분담이 쉬워지고 새로운 개발자도 구조 파악하기가 쉬

## 주의할 점

- **추상화만 하고 실체가 없으면 의미가 없음**
    - Repository는 "인터페이스"처럼 역할을 정의하는 계층이지만, **실제로 사용할 DataSource 구현이 명확히 연결돼야 한다.**
    - 예를 들어, Repository는 정의했는데 Firebase, REST API, Local 등 실제 구현이 빠져 있다면 패턴이 무의미해진다.
    - 해결 팁
        - 항상 `abstract class`와 그에 대한 `implements` 클래스를 한 쌍으로 만들기!
- **너무 많은 책임을 Repository에 몰아주지 않기**
    - Repository가 모든 걸 다 하려고 하면 **비대해지고 유지보수가 어려워져진다.**
    - 특히 비즈니스 로직(예: 날짜 계산, 필터링)을 Repository에 넣는 건 지양해야 한다.
    - **해결 팁**
        - Repository는 "데이터 입출력"만 담당.
        - **UseCase / ViewModel / Bloc**에서 비즈니스 로직을 처리하도록 분리하기.
- **모든 메소드에 `Future`  제대로 처리하기**
    - Repository는 보통 비동기 작업을 하게 되므로 `Future` 등을 정확히 써야 한다.
    - 동기 메소드로 구현하면, **await 없이 호출되어 에러** 발생할 수 있음
- **모델 클래스와 JSON 변환 혼재 주의**
    - 모델 클래스에서 직접 Firebase나 API 문서를 처리하게 하면 **응집도가 떨어짐**
    - **해결 팁**
        - `Model.fromJson()`과 `toJson()`을 잘 정의 해야 한.
        - 변환 작업은 **DataSource 계층에서 처리하도록 분리**해야 한다.