
# 강의 시작 전 지난 코드 리뷰 시간

- **"refactor : "**  
  리팩토링(refactoring)은 코드의 동작은 변경하지 않으면서 코드의 구조를 개선하는 작업을 의미한다. 즉, 코드를 더 깔끔하고 이해하기 쉽게 만든다.

- **lib를 playground로 변경하고, 과제 폴더를 lib로 변경**  

- **매직 넘버**: 상수로 정의할 수 있는 의미가 부여된 숫자  
  '매직 넘버(magic number)'는 코드에 하드코딩된 숫자들이다. 예를 들어, `if (x == 10)`처럼 특정 값을 코드에 직접 입력하는 경우가 매직 넘버에 해당한다. 매직 넘버를 사용하면 코드의 의도를 명확히 이해하기 어려울 수 있기 때문에, 의미 있는 이름을 가진 상수로 대체하는 것이 좋다.

- **편의성 플러그인** 추천 예정

---

# 추상클래스와 인터페이스 (abstract class, interface)

## 추상클래스

### 1. 상속의 재료로 사용되는 클래스
추상 클래스는 주로 다른 클래스들이 상속받아 사용할 수 있는 '상속의 재료'로 사용된다. 즉, 부모 클래스에서 기본적인 틀만 제공하고, 실제 구현은 자식 클래스에서 한다.

### 2. 일부 구현이 미정의된 클래스
추상 클래스는 기본적으로 구현되지 않은 메서드나 프로퍼티를 가질 수 있다. 이 메서드들은 자식 클래스에서 반드시 구현해야 하며, 이를 통해 자식 클래스들이 공통된 인터페이스를 따르도록 강제한다.

### 추상클래스 정의
- `abstract` 키워드를 사용하여 클래스를 선언한다. 예를 들어:

  ```dart
  abstract class Animal {
    void speak(); // 추상 메서드
  }
  ```

  이처럼 `speak()`와 같은 메서드는 구현되지 않은 상태로 두고, 이를 상속받은 자식 클래스에서 구체적인 구현을 하도록 한다.

### 추상클래스의 제약
추상 클래스는 **인스턴스화**가 불가능하다. 즉, 추상 클래스를 직접 객체로 생성할 수 없다. 예를 들어:

```dart
// 추상 클래스의 인스턴스를 만들 수 없다
// Animal animal = Animal(); // 오류 발생
```

이런 제약은 추상 클래스를 상속받은 구체적인 클래스들만 인스턴스화할 수 있도록 강제한다.

### 다계층의 추상 상속 구조
추상 클래스는 다계층 구조를 가질 수 있다. 예를 들어, 여러 계층의 클래스들이 추상 클래스를 상속하면서 점점 더 구체적인 내용을 구현할 수 있다.

- 다이어그램에서 이탈릭체(기울임꼴)는 추상 클래스나 추상 메서드를 나타낸다.
- `startuml` 파일에서 `{abstract}`를 사용하여 추상 클래스를 정의할 수 있다.

---

## 인터페이스 (Interface)

### 1. 모든 메서드는 추상 메서드여야 한다
인터페이스는 **모든 메서드가 추상 메서드**여야 한다. 즉, 메서드의 구현 없이 메서드의 서명만 정의한다. 클래스에서 이 인터페이스를 구현할 때, 정의된 모든 메서드를 구현해야 한다.

### 2. 필드를 가지지 않는다
인터페이스는 일반적으로 필드를 가질 수 없다. 필드는 값을 저장하는 변수인데, 인터페이스는 단지 메서드의 서명만 정의하므로, 필드는 사용할 수 없다.

### 추상 메서드만 가지는 추상 클래스 == 인터페이스
Dart에서는 `interface`라는 키워드 대신 `abstract class`를 사용하여 인터페이스를 구현한다. 사실상, 추상 클래스는 `interface` 역할도 할 수 있기 때문에, 이 둘을 구분하기가 애매하다. 예를 들어:

```dart
abstract class Human {
  void speak(); // 추상 메서드
}
```

### 인터페이스 활용
인터페이스는 기능을 정의하는데 사용된다. 즉, 클래스가 어떤 기능을 구현해야 하는지 정의할 수 있다. 인터페이스를 구현하는 클래스는 그 인터페이스에서 정의된 모든 메서드를 구현해야 한다.

예전에는 인터페이스를 구현하기 위해 `abstract class`를 사용했으나, Dart 3.0부터는 `interface` 키워드가 도입되어 인터페이스 구현을 더 명확하게 표현할 수 있게 되었다.

---

## implements vs extends

### implements
- **`implements`** 키워드는 인터페이스를 구현할 때 사용된다. 클래스가 인터페이스를 구현하면, 해당 인터페이스에서 정의된 메서드를 반드시 구현해야 한다.

```dart
class Human implements Speakable {
  @override
  void speak() {
    print("Hello!");
  }
}
```

### extends
- **`extends`** 키워드는 클래스 상속에 사용된다. 부모 클래스의 속성이나 메서드를 자식 클래스가 상속받고, 필요에 따라 재정의(override)할 수 있다.

```dart
class Hero extends Character {
  @override
  void attack() {
    print("Hero attacks!");
  }
}
```

---

## 인터페이스의 특별 취급

### 여러 인터페이스를 구현할 수 있다
Dart에서는 **다중 상속**을 지원하지 않지만, **여러 개의 인터페이스를 구현**하는 것은 가능하다. 이를 통해 클래스가 다양한 기능을 가져올 수 있다.

```dart
class Hero implements Attackable, Movable {
  final String name;
  int hp = 100;

  Hero(this.name);

  @override
  void attack() {
    print("$name attacks!");
  }

  @override
  void move() {
    print("$name moves!");
  }
}
```

---

## 추상클래스와 인터페이스의 차이점

1. **추상클래스(abstract class)**는 일부 구현이 미정의된 클래스이고, **인터페이스(interface)**는 오직 메서드 서명만 정의한 기능적인 계약이다.
2. 추상클래스는 **상속**을 위한 기본 클래스로 사용되고, 인터페이스는 **기능을 제공**하는 역할을 한다.
3. **인터페이스**는 여러 개를 구현할 수 있지만, **추상클래스**는 한 번에 하나만 상속할 수 있다.

---

## extends와 implements 를 동시에 사용

Dart에서는 `extends`와 `implements`를 동시에 사용할 수 있다. 클래스가 상속을 받으면서, 추가로 인터페이스를 구현할 수 있는 구조다.

```dart
class Hero extends Character implements Attackable {
  String name;
  int hp;

  Hero({required this.name, required this.hp}) : super(name: name, hp: hp);

  @override
  void attack(Slime target) {
    print('$name의 물리 공격!');
    target.hp -= 10;
    print('${target.name}에게 10의 데미지! (남은 HP: ${target.hp})');
  }

  @override
  void defend() {
    print('$name의 방어!');
    print('5의 방어력을 얻었다');
  }
}
```

---

## 정리

### 개발자의 입장에서 상속의 재료를 작성하는 역할

- 다른 사람이 상속의 재료로 사용할 부모 클래스를 만드는 개발자가 있다. 이 개발자의 사명은 효율적이고 잘 설계된 부모 클래스를 만드는 것이다.
- 추상 클래스와 인터페이스는 공통된 기능을 정의하고, 자식 클래스가 이를 구체적으로 구현하도록 강제하는 역할을 한다.

### 추상 클래스

- 구현되지 않은 메서드가 있는 클래스는 `abstract`로 정의하며, 추상 클래스는 **인스턴스를 만들 수 없다**.
- 추상 클래스를 활용하면 예기치 않은 인스턴스화나 미구현 메서드의 오버라이드 걱정을 줄일 수 있다.

### 인터페이스

- **인터페이스**는 추상 클래스 중에서 메서드만 정의된 클래스를 특별히 분류한 것이다. 이를 통해 다중 상속 효과를 낼 수 있다.
- 인터페이스를 구현하면, 클래스는 그 인터페이스에서 정의한 메서드를 반드시 구현해야 한다.
