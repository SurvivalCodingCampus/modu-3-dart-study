* test
* 수동 테스트 : 인간이 하는 테스트(print)
* 단위 테스트 : 1개의 함수를 테스트 (test 코드)
* 통합 테스트 : 여러개 연관된 클래스나 함수를 함께 테스트 (UI 테스트, integration test)

* test 방법론
* 화이트 박스 테스트 : 내부 구조와 동작에 중점을 두고 테스트하는 방법
* 코드의 내부 로직, 제어 흐름, 데이터 흐름 등을 이해하고 검증하는 데에 사용
* 테스트 케이스를 설계할 때 코드의 특정 부분을 직접 확인
* 주요 기법으로는 구문 검사, 경로 검사, 조건/분기 검사 등이 있다.

* 블랙 박스 테스트
* 소프트웨어의 내부 구조를 무시하고 기능을 테스트 하는 방법
* 시스템이 어떻게 동작하는지에 대한 내부 정보를 알 필요 없이 사용자 관점에서 테스트
* 테스트 케이스는 입력 값과 예상 출력 값에 기반하여 설계
* 요구 사항을 충족하는지 확인하고, 시스템의 기능적 및 비기능적 요구 사항을 테스트
* 주요 기법으로는 등가 분할, 경계 값 분석, 상태 전이 테스트 등이 있다.
1. 등가 분할(Equivalence Partitioning)
정의:
시스템의 입력 데이터를 유사한 결과가 예상되는 여러 그룹(등가 클래스)으로 나누어 테스트하는 기법입니다.
각 그룹에서 대표 값을 선택하여 테스트함으로써 모든 입력 데이터를 테스트하는 것과 동일한 효과를 얻을 수 있습니다.
목적:
테스트 케이스 수를 줄여 효율성을 높이고, 테스트 범위의 누락을 방지합니다.
예시:
나이를 입력받는 시스템에서 유효한 나이 범위(예: 1~120세)를 설정한 경우, 다음과 같이 그룹을 나눌 수 있습니다.
유효한 그룹: 1~120
유효하지 않은 그룹: 0 이하, 121 이상

2. 경계 값 분석(Boundary Value Analysis)

정의:
등가 분할에서 나눈 각 그룹의 경계 값(최솟값, 최댓값, 바로 앞 값, 바로 다음 값)을 중심으로 테스트하는 기법입니다.
경계 값에서 오류가 발생할 확률이 높다는 경험적 사실에 기반합니다.
목적:
경계 조건에서 발생하는 오류를 집중적으로 검출합니다.
예시:
나이 입력 범위가 1~120세인 경우, 다음과 같은 값을 테스트 값으로 사용합니다.
0, 1, 2, 119, 120, 121

3. 상태 전이 테스트(State Transition Testing)
정의:
시스템의 상태 변화를 모델링하여 테스트하는 기법입니다.
시스템의 모든 가능한 상태와 상태 변화(전이)를 정의하고, 각 전이에 대한 테스트 케이스를 설계합니다.
목적:
시스템의 동적인 동작과 상태 변화에 따른 오류를 검출합니다.
예시:
자동판매기의 상태와 상태 변화를 다음과 같이 모델링할 수 있습니다.
상태: 대기, 결제 중, 상품 제공, 오류
상태 변화: 동전 투입, 상품 선택, 잔돈 반환
요약

등가 분할은 입력 데이터를 그룹으로 나누어 효율성을 높입니다.
경계 값 분석은 경계 조건에서 오류를 집중적으로 검출합니다.
상태 전이 테스트는 시스템의 동적인 동작과 상태 변화를 검증합니다.

* (Unit) 단위 테스트 : 특정 모듈이 의도한 대로 잘 작동하는가를 테스트하는 가장 작은 단위의 테스트. 모듈 = 메서드, 기능

* 테스트의 장점
* 장애에 관한 신속한 피드백
* 개발 주기에서 조기 장애 감지
* 회귀에 신경 쓸 필요 없이 코드를 최적화 할 수 있도록 하는 더 안전한 코드 리팩터링
* 기술적 문제를 최소화하는 안정적인 개발 속도

* 단위 테스트가 꼭 필요한 경우
* DB 
- 스키마가 변경되는 경우
- 모델 클래스가 변경되는 경우
* Networkl
-  예측한 데이터가 제대로 들어오는지
* 데이터 검증
- 예측한 데이터를 제대로 처리하고 있는지

* 테스트 중심으로 개발하는 방법론을 TDD(Test Driven Development)라고 한다.
* 특정 테스트가 예외가 발생되어야 하는 것을 테스트 
```
expect(() => a.transfer(b, 600), throwsException);
```
반대는 returnsNormally

* 좋은 Unit Test 의 6가지 조건
* Fast, Reliable, Independent, Ease of Maintenance, Nearly compacted code, Dependencies should be less

* Model Class 의 책임과 역할
* 모델 객체 클래스의 속성에 대한 데이터를 조회할 수 있는 클래스
* 일반적으로 별도의 기능을 가지지 않는 순수한 클래스로 작성
* 데이터 소스를 앱에서 필요한 형태로 변환한 데이터, 앱 개발을 편리하게 해주는 역할
* DDD (Domain Driven Design)
- Domain 의 정의
- 유사한 업무의 집합
- 특정 상황(주문, 결재, 로그인)이나 특정 객체(유저, 손님)가 중심이 될 수 있음
- 모델 클래스
- 도메인을 클래스로 작성한 것
* ORM (Object-relational mapping)
- 데이터 소스가 DB 인 경우 DB 와 모델간 상호 변환을 도와주는 기법
- ORM은 DB 를 활용할 경우에 따로 살펴봐도 됨
  
* model class
* 불변 객체
  값 변경을 위해 copyWith() 제공
  ==, hashCode 재정의
  toString() 재정의
  (옵션) 직렬화, 역직렬화 제공

* Repository 패턴은 소프트웨어 개발에서 데이터 저장소에 접근하는 객체를 추상화하고,
  데이터소스(DB, File 등)와의 통신을 담당하는 객체를 캡슐화하는 디자인 패턴이다

* Repository의 책임과 역할
  데이터 접근에 대한 추상화 계층
  데이터 소스 은닉
  도메인 객체와 데이터 소스 사이의 중재자
  데이터 매핑, 변환 담당

* Repository 패턴의 이점
* 데이터 접근 추상화
  데이터 소스 구현 세부사항 은닉
  일관된 인터페이스 제공
유지보수성 향상
  관심사 분리
  코드 재사용성
* 테스트 용이성
데이터 소스 Mocking 가능
단위 테스트 작성 용이
* 확장성
새로운 데이터 소스 추가 용이
기존 코드 수정 최소화
인터페이스 기반 설계

* 도메인 특화 기능을 Repository 가 제공하는 경우의 장점
* 도메인 의도가 명확히 드러남
  재사용 가능한 쿼리 로직
  데이터 소스 구현과 분리된 비즈니스 요구사항 처리

* 주의
  Repository는 비즈니스 로직에 집중
  복잡한 비즈니스 로직은 더 상위 계층으로
  성능을 고려한 쿼리 설계 필요

