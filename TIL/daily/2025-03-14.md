# 레퍼런스 타입과 참조

## 가상세계와 메모리 구조

컴퓨터에서 프로그램이 실행되면, 여러 개의 메모리 영역이 사용됨. Dart의 메모리 구조를 이해하면 객체가 어떻게 생성되고 관리되는지 알 수 있음.

### 1. **메모리의 주요 영역**

1. **스택(Stack) 영역**
    - **지역 변수**(함수 내에서 선언된 변수)와 **메서드 호출 정보(호출 스택)** 저장
    - **컴파일 타임**(코드 실행 전) 할당 및 해제
    - **LIFO(Last-In First-Out)** 방식으로 관리됨
    - 기본 자료형(`int`, `double`, `bool`)과 참조 타입의 **참조값(메모리 주소)** 저장
    - 스택 프레임(Stack Frame): 함수 호출 시마다 개별적으로 생성됨
2. **힙(Heap) 영역**
    - **객체(클래스의 인스턴스)와 동적 메모리 할당이 필요한 데이터 저장**
    - 런타임 중 동적으로 크기가 결정됨
    - **Garbage Collector(GC)** 가 사용되지 않는 객체를 자동으로 해제
    - **Dart에서는 모든 데이터가 참조형(Reference Type)** → 객체는 **Heap에 저장**되며, 스택에는 참조값이 저장됨
3. **코드(Code) 영역**
    - 실행할 프로그램의 **코드(바이트코드, 명령어 등) 저장**
    - 보통 실행 중 변하지 않음(읽기 전용)
4. **데이터(Data) 영역**
    - 전역 변수, `static` 변수 등 프로그램이 실행되는 동안 유지되어야 하는 데이터 저장
    - **프로그램이 종료될 때까지 메모리에 유지됨**

---

### 2. **Dart에서의 메모리 관리**

- Dart의 모든 데이터는 **레퍼런스 타입**
    - `int`, `double`, `String` 등의 기본형조차도 **Heap에 저장**되며, Stack에는 참조값(메모리 주소)만 저장됨
- **Garbage Collector(GC) 작동 방식**
    - 사용되지 않는 객체는 자동으로 정리됨 (메모리 누수 방지)
    - **`final` 키워드**를 사용하면 변수 변경을 방지할 수 있지만, 메모리 할당 방식 자체는 달라지지 않음

---

### 3. **메모리 관련 Android Studio 기능**

- **메모리 UI 활성화 가능**
    - 개발 도중 **실시간으로 메모리 사용량 확인 가능**
- **메모리 정리 가능**
    - UI에서 **GC(가비지 컬렉션) 수동 실행 가능**
- **JVM(Java Virtual Machine) 관련 사항**
    - Dart는 AOT(Ahead-Of-Time) 컴파일을 사용하여 네이티브 코드로 변환되므로 Java와 다르게 동작
    - 하지만, Android 개발 환경에서는 **JVM이 백그라운드에서 실행될 수 있음**

---

# 두 개의 `Hero` 변수

```dart
final hero1 = Hero(name: '홍길동', hp: 100);
final hero2 = hero1;

hero2.hp = 200;

```

- `hero1.hp` 값은? → **200**
- 인스턴스 개수는? → **하나**
    - `hero1`과 `hero2`는 같은 메모리 주소를 참조하기 때문

---

# 생성자 (Constructor)

## 생성자 정의 방식

- **네임드 파라미터 (Named Parameter)**
    - 중괄호 `{}` 로 감싸고 `required` 키워드 사용
    - **가독성 향상** → 가능하면 네임드 파라미터 사용 권장

```dart
class Sword {
  String name;
  int damage;

  Sword({required this.name, required this.damage});
}

```

## 널러블 (Nullable) 처리

```dart
class Hero {
  String name;
  int hp;
  Sword? sword; // nullable

  Hero({required this.name, required this.hp, this.sword});
}

```

- `sword`는 **nullable** 타입(`Sword?`)으로 선언
- 생성 시 인스턴스를 직접 대입하거나 나중에 할당 가능

---

# 파라미터 정리

- **필수 파라미터 (Positional Parameter)**
    - 일반적인 생성자에서 사용되는 기본 파라미터
- **네임드 파라미터 (Named Parameter)**
    - `{}` 를 사용하며, 필요 시 `required` 키워드 추가
- **옵셔널 파라미터 (Optional Parameter)**
    - [ ]  `[ ]` 를 사용하여 선택적으로 제공 가능

### 예제: 필수 + 네임드 파라미터

```dart
class Hero {
  String name;
  int hp;
  Sword? sword;

  Hero(this.name, this.hp, {this.sword});
}

```

- **필수 파라미터** → `name`, `hp`
- **옵셔널 네임드 파라미터** → `{this.sword}`
- **필수 파라미터가 먼저 와야 함**

💡 **Tip**

- **Ctrl + Alt + L** → 코드 정리 (Android Studio)
- 네임드 파라미터 사용 시 **마지막 파라미터 뒤에 콤마 `,` 없음** (자동 정리됨)

---

# 기본값 설정

- 클래스에서 직접 값을 할당하는 것보다 **생성자를 통해 기본값을 설정하는 것이 좋다**

```dart
class Cleric {
  String name;
  int hp;
  int mp;

  final int maxHp = 50;
  final int maxMp = 10;

  Cleric(this.name, {this.hp = 50, this.mp = 10});
}

```

- `maxHp`와 `maxMp`는 `final`이므로 생성자에서 초기화할 필요 없음
- `{this.hp = 50, this.mp = 10}` → **디폴트 값 제공 가능**

---

# 생성자의 오버로드

- Dart에서는 **생성자 오버로딩을 문법적으로 지원하지 않음**
- 하지만 **네임드 생성자(named constructor)를 사용하여 비슷한 기능을 구현 가능**

**💡 오버로드(Overload)란?**

- 같은 이름의 생성자(또는 함수)를 **여러 개 정의**하는 기능
- Dart에서는 `factory` 생성자나 네임드 생성자를 활용하여 구현

---

# 타 생성자 용법

Dart에서는 다양한 방식으로 생성자를 정의할 수 있음.

## 기본 생성자

- 생성자를 **명시적으로 작성하지 않아도 기본 생성자(default constructor)가 자동 생성됨**

```dart
class Person {
  Person();
}

void main() {
  Person person = Person();
}

```

- 위 코드처럼 **생성자가 아무것도 하지 않아도 사용 가능**

---

## 필드를 가진 생성자

- 필드가 있는 경우에도 생성자를 명시적으로 정의할 수 있음

```dart
class Person {
  String name;
  Person();
}

```

---

## `assert` 문과 콜론(`:`)을 이용한 초기화

Dart에서는 생성자 내부에서 **초기화 리스트(initializer list)** 를 사용할 수 있음.

초기화 리스트는 **콜론(`:`)을 사용하여 필드 값을 초기화**하거나 **`assert` 문을 활용**하는 방식으로 사용됨.

### 예제: `assert` 문 사용

```dart
class Hero {
  String name;
  int hp;

  Hero(this.name, this.hp) : assert(hp > 0, "HP는 0보다 커야 합니다.");
}

```

- `assert` 문은 **디버깅 모드에서만 동작**하며, 조건을 만족하지 않으면 오류 발생

### 예제: 콜론(`:`)을 활용한 초기화

```dart
class Hero {
  final String name;
  final int hp;

  // 초기화 리스트 사용
  Hero(String name, int hp)
      : name = name,
        hp = hp > 0 ? hp : 1; // hp가 0 이하이면 1로 설정
}

```

- **초기화 리스트를 활용하면 생성자 본문 실행 전에 필드를 초기화 가능**
- 특히, `final` 필드는 생성자 내부에서 직접 할당할 수 없으므로 **초기화 리스트를 사용해야 함**

---

# `static` 키워드를 사용한 필드 공유

## 1. 일반적인 변수 선언

```dart
int money = 100;

class Hero {
  // ...
}

```

- **탑 레벨 변수(top-level variable)** → 어디서든 `import` 해서 사용 가능
- 하지만 **유지보수에 좋지 않은 방식**

---

## 2. `static` 필드를 활용한 공유 자원

```dart
class Hero {
  static int money = 100;
}

```

- `static` 키워드를 사용하여 **클래스 단위에서 공유할 수 있도록 필드 선언**
- 모든 **Hero 인스턴스가 동일한 `money` 값을 공유**
- **클래스 내부에서 공유하는 방식이므로 유지보수에 더 유리함**

---

## 3. `static` 필드 접근 방법

```dart
void main() {
  print(Hero.money); // 100
}

```

- **인스턴스 없이도 접근 가능**
- 이미 메모리에 할당되어 있음

---

## 4. `static` 필드와 인스턴스 필드의 차이

```dart
class Hero {
  static int money = 100; // 정적 필드 (클래스 단위로 공유)
  int hp = 50; // 인스턴스 필드 (각 객체별로 개별 할당)
}

void main() {
  Hero hero1 = Hero();
  Hero hero2 = Hero();

  hero1.hp = 30;
  Hero.money = 200; // 클래스 필드 변경

  print(hero1.hp); // 30
  print(hero2.hp); // 50 (인스턴스별 개별 값)
  print(Hero.money); // 200 (공유됨)
}

```

- **정적(static) 필드**는 모든 객체가 공유
- **인스턴스 필드**는 객체별로 별도 저장됨

---

## 5. `static` 메소드 사용

```dart

class Hero {
  static int money = 100;

  static void showMoney() {
    print("현재 소지금: $money");
  }
}

void main() {
  Hero.showMoney(); // 현재 소지금: 100
}

```

- 정적 필드와 동일하게, **정적 메소드도 인스턴스 없이 호출 가능**
- `Hero.showMoney();` → 클래스 이름을 통해 직접 접근

---

## 6. `static` 필드 사용 방식

```dart
Hero.money = 100; // ✅ 올바른 접근 방식
hero.money = 100; // ❌ 오류 발생 (인스턴스에서는 접근 불가능)

```

- **클래스 단위(`Hero.money`)로 접근해야 함**
- 인스턴스(`hero.money`)에서는 접근 불가능

---

# 정리

레퍼런스 타입의 참조

- 레퍼런스 타입 변수의 안에는 “인스턴스의 정보가 담겨있는 메모리 번지"가 들어 있다
- 어떤 레퍼런스 타입 변수를 다른 변수에 대입하면, 주소만 복사 된다.
- 레퍼런스 타입은 필드나 메소드의 인수, 리턴 값의 형으로서도 이용된다

생성자

- “클래스명과 동일 명칭으로, 리턴 값의 타입이 명시되어 있지 않은 메소드"는 생성자로 사용된다.
- 생성자는 new 에 의한 인스턴스화의 직후에 자동적으로 실행 된다. Dart 에서 new는 생략 가능
- 인수를 가지는 생성자를 정의하면, new 를 할 때에 인수를 지정하여 생성자를 실행할 수 있다
- 생성자는 오버로드에 의한 복수 정의가 된다.
- 클래스에 생성자 정의가 1개도 없는 경우에 한해, 컴파일러가 “인수없음, 처리내용없음"의 기본 생성자를 자동정의 해 준다.

정적 멤버

- static 키워드가 붙어 있는 정적 멤버(필드 또는 메소드) 는

1. 각 인스턴스가 아닌, 클래스에 실체가 준비된다.

2. 인스턴스를 1개도 생성하지 않아도 이용 가능

- 정적 메소드는 그 내부에 정적이지 않은 메소드나 필드를 이용하는 것이 불가능하다

---

# 연습문제 1

Cleric클래스에 관하여, 2가지 수정을 하시오

1. 현시점의 Cleric 클래스의 정의에는, 각 인스턴스별로 최대 HP와 최대 MP 필드에 대한 정보를 가지고 있다. 하지만, 모든 성직자의 최대 HP 는 50, 최대 MP 는 10으로 정해져 있어, 각 인스턴스가 각각의 정보를 가지는 것은 메모리 낭비이다.

   그래서, 최대 HP, 최대 MP의 필드가 공유 되도록

   필드 선언에 적절한 키워드를 추가하시오


| **항목** | **설명** |
| --- | --- |
| **문제점** | 각 인스턴스가 개별적으로 최대 HP, 최대 MP 값을 가짐 (메모리 낭비) |
| **해결 방법** | 최대 HP, 최대 MP를 **클래스 변수(`static`)** 로 선언 |
| **사용 키워드** | `static` |
| **결과** | 모든 인스턴스가 동일한 최대 HP, 최대 MP 값을 공유 |

2. 아래의 방침에 따라, 생성자를 추가 하시오

1. 이 클래스는 Cleric(“아서스", hp: 40, mp: 5) 와 같이, 이름, HP, MP 를 지정하여 인스턴스화 할 수 있다
2. 이 클래스는 Cleric(“아서스", hp: 35) 와 같이, 이름과 HP만으로 지정하여 인스턴스화 할 수 있다. 이 때, MP는 최대 MP와 같은 값이 초기화 된다
3. 이 클래스는 Cleric(“아서스") 와 같이 이름만을 지정하여 인스턴스화 할 수 있다. 이 때, HP 와 MP 는 최대 HP와 최대 MP로 초기화 된다
4. 이 클래스는 Cleric() 과 같이 이름을 지정하지 않는 경우에는 인스턴스화 할 수 없다고 한다. (이름이 없는 성직자는 존재 할 수 없음)
5. 생성자는 가능한 한 중복되는 코드가 없도록 작성한다

| **생성 방식** | **초기화 값** | **설명** |
| --- | --- | --- |
| `Cleric("아서스", hp: 40, mp: 5)` | HP: 40, MP: 5 | 이름, HP, MP를 직접 지정 |
| `Cleric("아서스", hp: 35)` | HP: 35, MP: 최대 MP | 이름과 HP만 지정, MP는 최대 MP로 설정 |
| `Cleric("아서스")` | HP: 최대 HP, MP: 최대 MP | 이름만 지정, HP와 MP는 최대값으로 설정 |
| `Cleric()` | **생성 불가** | 이름 없는 Cleric 인스턴스는 허용되지 않음 |
| **중복 최소화** | **초기화 리스트 사용** | 선택적 매개변수(`{}`)와 기본값 설정으로 코드 간결화 |
